<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatiotemporal Dracula</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        header {
            background-color: #2d0a0a;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #8b0000;
        }

        h1 {
            color: #c41e3a;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            color: #a0a0a0;
            margin-top: 5px;
        }

        #map-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
        }

        #map {
            flex: 1;
            min-height: 400px;
        }

        #content-panel {
            background-color: #2a2a2a;
            padding: 20px;
            border-top: 2px solid #8b0000;
            max-height: 400px;
            overflow-y: auto;
        }

        #content-panel h3 {
            color: #c41e3a;
            margin-bottom: 10px;
        }

        #content-text {
            line-height: 1.6;
            color: #d0d0d0;
        }

        .leaflet-popup-content-wrapper {
            background-color: #2d0a0a;
            color: #f0f0f0;
            border: 2px solid #8b0000;
        }

        .leaflet-popup-tip {
            background-color: #2d0a0a;
        }

        .leaflet-popup-content {
            margin: 15px;
        }

        .popup-title {
            font-weight: bold;
            color: #c41e3a;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .popup-date {
            color: #a0a0a0;
            font-style: italic;
            margin-bottom: 10px;
        }

        .popup-content {
            color: #d0d0d0;
            line-height: 1.5;
        }

        /* Timeline slider styling */
        .time-slider-container {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-top: 2px solid #8b0000;
        }

        .time-slider-label {
            color: #c41e3a;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        #time-slider {
            width: 100%;
            cursor: pointer;
        }

        .time-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .time-controls button {
            background-color: #8b0000;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
        }

        .time-controls button:hover {
            background-color: #c41e3a;
        }

        .time-controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #current-date {
            color: #f0f0f0;
            font-size: 1.1em;
        }

        .instructions {
            background-color: #333;
            padding: 10px 20px;
            color: #a0a0a0;
            font-size: 0.9em;
            text-align: center;
        }

        /* Ant path animation for LineStrings */
        @keyframes ant-path {
            to {
                stroke-dashoffset: -20;
            }
        }

        .ant-path-line {
            stroke-dasharray: 10, 10;
            animation: ant-path 1s linear infinite;
        }

        .ant-path-line-active {
            stroke-dasharray: 10, 10;
            animation: ant-path 0.5s linear infinite;
        }

        /* Arrow decoration styles */
        .leaflet-interactive[class*="arrow-decorator"] {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <header>
        <h1>ü¶á Spatiotemporal Dracula ü¶á</h1>
        <p class="subtitle">Journey through the locations and events of Bram Stoker's Dracula</p>
    </header>

    <div class="instructions">
        Use the timeline slider below the map to step through events. Click on markers and paths for more details.
    </div>

    <div id="map-container">
        <div id="map"></div>

        <div class="time-slider-container">
            <span class="time-slider-label">Timeline</span>
            <input type="range" id="time-slider" min="0" max="100" value="0" step="1">
            <div class="time-controls">
                <button id="prev-btn">‚èÆ Previous</button>
                <button id="next-btn">Next ‚è≠</button>
                <span id="current-date">Loading...</span>
            </div>
        </div>

        <div id="content-panel">
            <div id="content-text">Select an entry from the timeline to view its content.</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Polyline Decorator for arrows -->
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>

    <script>
        // Initialize map
        const map = L.map('map').setView([48.0, 15.0], 4);

        // Add dark tile layer
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            maxZoom: 19
        }).addTo(map);

        // Custom marker icons
        const draculaIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="background-color: #8b0000; width: 12px; height: 12px; border-radius: 50%; border: 2px solid #c41e3a; box-shadow: 0 0 10px rgba(139, 0, 0, 0.8);"></div>',
            iconSize: [16, 16],
            iconAnchor: [8, 8]
        });

        const activeIcon = L.divIcon({
            className: 'custom-marker-active',
            html: '<div style="background-color: #c41e3a; width: 18px; height: 18px; border-radius: 50%; border: 3px solid #ff6b6b; box-shadow: 0 0 20px rgba(196, 30, 58, 1);"></div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12]
        });

        // Store features and map objects
        let features = [];
        let mapObjects = []; // Will store { type: 'marker'|'line', layer: ..., decorator: ... }
        let currentIndex = 0;

        // Helper functions
        function getTitle(props) {
            if (props.chapter_title && props.chapter_title.trim()) {
                return props.chapter_title;
            }
            if (props.entry_type && props.author) {
                return `${props.entry_type} - ${props.author}`;
            }
            if (props.entry_type) {
                return props.entry_type;
            }
            return `Entry ${props.sequence_in_book || props.entry_id || ''}`;
        }

        function getDate(props) {
            return props.date_normalized || props.date_raw || '';
        }

        function formatDisplayText(props) {
            const date = getDate(props);
            const entryType = props.entry_type ? props.entry_type.toUpperCase() : '';
            const author = props.author || '';
            const recipient = props.recipient || '';

            let text = date;
            if (entryType) {
                text += ` - ${entryType}`;
            }
            if (author && recipient) {
                text += ` - ${author} to ${recipient}`;
            } else if (author) {
                text += ` - ${author}`;
            }

            return text;
        }

        function convertItalics(text) {
            if (!text) return '';
            // Convert _text_ to <em>text</em>
            return text.replace(/_((?:[^_]|\\_.)+?)_/g, '<em>$1</em>');
        }

        function truncateContent(content, maxLength = 300) {
            if (!content) return '';
            const converted = convertItalics(content);
            if (converted.length <= maxLength) return converted;
            return converted.substring(0, maxLength) + '...';
        }

        function createPopupContent(props) {
            return `<div style="color: #f0f0f0; font-size: 1em;">${formatDisplayText(props)}</div>`;
        }

        // Create map objects from features (but don't add to map yet)
        function createMapObject(feature, index) {
            const geom = feature.geometry;

            // Skip features with null geometry
            if (!geom || geom.type === null) {
                return null;
            }

            const props = feature.properties;
            const popupContent = createPopupContent(props);

            if (geom.type === 'Point') {
                // Create point marker (not added to map yet)
                const coords = geom.coordinates;
                const marker = L.marker([coords[1], coords[0]], { icon: activeIcon });
                marker.bindPopup(popupContent, { maxWidth: 350 });

                marker.on('click', () => {
                    currentIndex = index;
                    updateTimelineUI();
                    displayContent(feature);
                });

                return { type: 'marker', layer: marker, decorator: null };

            } else if (geom.type === 'LineString') {
                // Create polyline with ant path animation (not added to map yet)
                const coords = geom.coordinates.map(c => [c[1], c[0]]);
                const line = L.polyline(coords, {
                    color: '#c41e3a',
                    weight: 4,
                    opacity: 1,
                    className: 'ant-path-line-active'
                });

                line.bindPopup(popupContent, { maxWidth: 350 });

                // Add arrow decorators
                const decorator = L.polylineDecorator(line, {
                    patterns: [
                        {
                            offset: '100%',
                            repeat: 0,
                            symbol: L.Symbol.arrowHead({
                                pixelSize: 15,
                                polygon: false,
                                pathOptions: {
                                    stroke: true,
                                    color: '#c41e3a',
                                    weight: 3
                                }
                            })
                        },
                        {
                            offset: '50%',
                            repeat: 0,
                            symbol: L.Symbol.arrowHead({
                                pixelSize: 12,
                                polygon: false,
                                pathOptions: {
                                    stroke: true,
                                    color: '#c41e3a',
                                    weight: 2
                                }
                            })
                        }
                    ]
                });

                line.on('click', () => {
                    currentIndex = index;
                    updateTimelineUI();
                    displayContent(feature);
                });

                return { type: 'line', layer: line, decorator: decorator };
            }

            return null;
        }

        // Load GeoJSON data
        fetch('data/dracula_part1.geojson')
            .then(response => response.json())
            .then(data => {
                // Sort features by date_normalized, then by sequence_in_book
                features = [...data.features].sort((a, b) => {
                    const dateA = a.properties.date_normalized || '';
                    const dateB = b.properties.date_normalized || '';

                    if (dateA !== dateB) {
                        return dateA.localeCompare(dateB);
                    }

                    return (a.properties.sequence_in_book || 0) - (b.properties.sequence_in_book || 0);
                });

                // Create map objects for all features
                features.forEach((feature, index) => {
                    const obj = createMapObject(feature, index);
                    if (obj) {
                        mapObjects.push(obj);
                    }
                });

                // Set up the timeline slider
                const slider = document.getElementById('time-slider');
                slider.max = features.length - 1;

                // Initialize with first feature
                updateTimelineUI();
                displayContent(features[0]);
            })
            .catch(error => {
                console.error('Error loading GeoJSON:', error);
                document.getElementById('content-text').textContent = 'Error loading data. Please try again later.';
            });

        // Set up event listeners
        const slider = document.getElementById('time-slider');

        slider.addEventListener('input', (e) => {
            currentIndex = parseInt(e.target.value);
            updateTimelineUI();
            if (features[currentIndex]) {
                displayContent(features[currentIndex]);
            }
        });

        // Navigation buttons
        document.getElementById('prev-btn').addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateTimelineUI();
                displayContent(features[currentIndex]);
            }
        });

        document.getElementById('next-btn').addEventListener('click', () => {
            if (currentIndex < features.length - 1) {
                currentIndex++;
                updateTimelineUI();
                displayContent(features[currentIndex]);
            }
        });

        function updateTimelineUI() {
            if (features.length === 0) return;

            slider.value = currentIndex;

            // Update button states
            document.getElementById('prev-btn').disabled = currentIndex === 0;
            document.getElementById('next-btn').disabled = currentIndex === features.length - 1;

            // Remove all map objects from map
            mapObjects.forEach((obj) => {
                if (map.hasLayer(obj.layer)) {
                    map.removeLayer(obj.layer);
                }
                if (obj.decorator && map.hasLayer(obj.decorator)) {
                    map.removeLayer(obj.decorator);
                }
            });

            // Add only the current map object to map (if it exists)
            const currentObj = mapObjects[currentIndex];
            if (currentObj) {
                currentObj.layer.addTo(map);
                if (currentObj.decorator) {
                    currentObj.decorator.addTo(map);
                }

                // Pan to current feature only if geometry exists
                const feature = features[currentIndex];
                const geom = feature.geometry;

                if (geom && geom.type === 'Point') {
                    const coords = geom.coordinates;
                    map.flyTo([coords[1], coords[0]], 6, { duration: 1 });
                } else if (geom && geom.type === 'LineString') {
                    const bounds = currentObj.layer.getBounds();
                    map.flyToBounds(bounds, { duration: 1, padding: [50, 50] });
                }
            }
        }

        function displayContent(feature) {
            const props = feature.properties;
            const displayText = formatDisplayText(props);

            document.getElementById('current-date').textContent = displayText;

            // Use innerHTML to support italics formatting
            const contentElement = document.getElementById('content-text');
            const content = props.content || 'No content available.';
            contentElement.innerHTML = convertItalics(content);

            // Open popup on the current map object (if it exists and has geometry)
            if (mapObjects[currentIndex] && feature.geometry) {
                mapObjects[currentIndex].layer.openPopup();
            }
        }
    </script>
</body>

</html>